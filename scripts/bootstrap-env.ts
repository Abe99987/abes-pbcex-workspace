#!/usr/bin/env ts-node

import * as fs from 'fs';
import * as path from 'path';
import * as url from 'url';
import * as crypto from 'crypto';
import chalk from 'chalk';

// ES module equivalent of __dirname
const __filename = url.fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const ROOT_DIR = path.dirname(__dirname);

/**
 * PBCEx Environment Bootstrap üöÄ
 * 
 * Automatically sets up development environment configuration by:
 * 1. Copying template files if missing
 * 2. Generating secure random secrets
 * 3. Writing minimum required configuration
 * 4. Preserving existing real values
 * 
 * Usage: npm run setup:env
 */

interface EnvFile {
  path: string;
  templatePath: string;
  name: string;
}

interface SecretConfig {
  key: string;
  generator: () => string;
  description: string;
}

interface ConfigEntry {
  key: string;
  value: string;
  required: boolean;
  description: string;
}

class EnvironmentBootstrap {
  private actions: string[] = [];

  constructor() {
    console.log(chalk.blue.bold('\nüöÄ PBCEx Environment Bootstrap\n'));
    console.log(chalk.gray('Setting up development environment configuration...\n'));
  }

  async bootstrap(): Promise<void> {
    try {
      // Step 1: Copy template files
      await this.copyTemplateFiles();

      // Step 2: Bootstrap backend environment
      await this.bootstrapBackendEnv();

      // Step 3: Bootstrap frontend environment  
      await this.bootstrapFrontendEnv();

      // Step 4: Print summary
      this.printSummary();

    } catch (error) {
      console.error(chalk.red.bold('\nüí• Bootstrap failed:'));
      console.error(chalk.red(error.message));
      process.exit(1);
    }
  }

  private async copyTemplateFiles(): Promise<void> {
    console.log(chalk.cyan.bold('üìÑ Copying Template Files'));
    console.log(chalk.gray('‚îÄ'.repeat(50)));

    const envFiles: EnvFile[] = [
      {
        path: path.join(ROOT_DIR, 'backend', '.env'),
        templatePath: path.join(ROOT_DIR, 'backend', 'env-template'),
        name: 'Backend Environment'
      },
      {
        path: path.join(ROOT_DIR, 'frontend', '.env.local'),
        templatePath: path.join(ROOT_DIR, 'frontend', 'env-template'),
        name: 'Frontend Environment'
      }
    ];

    for (const envFile of envFiles) {
      if (!fs.existsSync(envFile.path)) {
        if (fs.existsSync(envFile.templatePath)) {
          fs.copyFileSync(envFile.templatePath, envFile.path);
          console.log(chalk.green(`   ‚úÖ Created ${envFile.name}`), chalk.gray(`‚Üí ${path.relative(ROOT_DIR, envFile.path)}`));
          this.actions.push(`Created ${envFile.name} from template`);
        } else {
          console.log(chalk.yellow(`   ‚ö†Ô∏è  Template missing for ${envFile.name}`), chalk.gray(`(${path.relative(ROOT_DIR, envFile.templatePath)})`));
          // Create empty file
          fs.writeFileSync(envFile.path, `# ${envFile.name}\n# Generated by PBCEx Bootstrap\n\n`);
          console.log(chalk.green(`   ‚úÖ Created empty ${envFile.name}`), chalk.gray(`‚Üí ${path.relative(ROOT_DIR, envFile.path)}`));
          this.actions.push(`Created empty ${envFile.name}`);
        }
      } else {
        console.log(chalk.blue(`   ‚ÑπÔ∏è  ${envFile.name} already exists`), chalk.gray(`‚Üí ${path.relative(ROOT_DIR, envFile.path)}`));
      }
    }
  }

  private async bootstrapBackendEnv(): Promise<void> {
    console.log(chalk.cyan.bold('\nüîß Backend Environment Configuration'));
    console.log(chalk.gray('‚îÄ'.repeat(50)));

    const backendEnvPath = path.join(ROOT_DIR, 'backend', '.env');
    const envContent = this.readEnvFile(backendEnvPath);

    // Secret configurations
    const secrets: SecretConfig[] = [
      {
        key: 'JWT_SECRET',
        generator: () => crypto.randomBytes(48).toString('base64url'),
        description: 'JSON Web Token signing secret'
      },
      {
        key: 'SESSION_SECRET',
        generator: () => crypto.randomBytes(48).toString('base64url'),
        description: 'Session cookie signing secret'
      },
      {
        key: 'ENCRYPTION_KEY',
        generator: () => crypto.randomBytes(32).toString('hex'),
        description: 'Data encryption key (64 hex chars)'
      }
    ];

    // Core configuration
    const configs: ConfigEntry[] = [
      { key: 'NODE_ENV', value: 'development', required: true, description: 'Node.js environment' },
      { key: 'PORT', value: '4001', required: true, description: 'Backend server port' },
      { key: 'DATABASE_URL', value: 'postgresql://postgres:postgres@localhost:5432/pbcex', required: true, description: 'PostgreSQL connection URL' },
      { key: 'REDIS_URL', value: 'redis://localhost:6379', required: true, description: 'Redis connection URL' },
      { key: 'PLAID_ENV', value: 'sandbox', required: false, description: 'Plaid environment' },
    ];

    let updated = false;

    // Generate and set secrets
    for (const secret of secrets) {
      const currentValue = envContent.get(secret.key);
      const needsGeneration = !currentValue || 
                             currentValue.trim() === '' ||
                             this.isPlaceholderValue(currentValue);

      if (needsGeneration) {
        const generatedValue = secret.generator();
        envContent.set(secret.key, generatedValue);
        console.log(chalk.green(`   ‚úÖ Generated ${secret.key}`), chalk.gray(`(${secret.description})`));
        this.actions.push(`Generated secure ${secret.key}`);
        updated = true;
      } else {
        console.log(chalk.blue(`   ‚ÑπÔ∏è  ${secret.key} already configured`));
      }
    }

    // Set core configurations
    for (const config of configs) {
      const currentValue = envContent.get(config.key);
      const needsUpdate = !currentValue || 
                         (config.required && (currentValue.trim() === '' || this.isPlaceholderValue(currentValue)));

      if (needsUpdate) {
        envContent.set(config.key, config.value);
        console.log(chalk.green(`   ‚úÖ Set ${config.key}`), chalk.gray(`= ${config.value}`));
        this.actions.push(`Set ${config.key} to ${config.value}`);
        updated = true;
      } else {
        const displayValue = this.maskSensitiveValue(config.key, currentValue);
        console.log(chalk.blue(`   ‚ÑπÔ∏è  ${config.key} already set`), chalk.gray(`= ${displayValue}`));
      }
    }

    if (updated) {
      this.writeEnvFile(backendEnvPath, envContent);
      console.log(chalk.green('\n   üìù Backend environment updated'));
    } else {
      console.log(chalk.blue('\n   ‚ÑπÔ∏è  Backend environment already properly configured'));
    }
  }

  private async bootstrapFrontendEnv(): Promise<void> {
    console.log(chalk.cyan.bold('\nüåê Frontend Environment Configuration'));
    console.log(chalk.gray('‚îÄ'.repeat(50)));

    const frontendEnvPath = path.join(ROOT_DIR, 'frontend', '.env.local');
    const envContent = this.readEnvFile(frontendEnvPath);

    const configs: ConfigEntry[] = [
      { key: 'NEXT_PUBLIC_APP_NAME', value: 'PBCEx', required: true, description: 'Application name' },
      { key: 'NEXT_PUBLIC_API_BASE_URL', value: 'http://localhost:4001', required: true, description: 'Backend API URL' },
      { key: 'NODE_ENV', value: 'development', required: false, description: 'Node.js environment' },
    ];

    let updated = false;

    for (const config of configs) {
      const currentValue = envContent.get(config.key);
      const needsUpdate = !currentValue || 
                         (config.required && (currentValue.trim() === '' || this.isPlaceholderValue(currentValue)));

      if (needsUpdate) {
        envContent.set(config.key, config.value);
        console.log(chalk.green(`   ‚úÖ Set ${config.key}`), chalk.gray(`= ${config.value}`));
        this.actions.push(`Set frontend ${config.key}`);
        updated = true;
      } else {
        console.log(chalk.blue(`   ‚ÑπÔ∏è  ${config.key} already set`), chalk.gray(`= ${currentValue}`));
      }
    }

    if (updated) {
      this.writeEnvFile(frontendEnvPath, envContent);
      console.log(chalk.green('\n   üìù Frontend environment updated'));
    } else {
      console.log(chalk.blue('\n   ‚ÑπÔ∏è  Frontend environment already properly configured'));
    }
  }

  private readEnvFile(filePath: string): Map<string, string> {
    const envMap = new Map<string, string>();
    
    if (!fs.existsSync(filePath)) {
      return envMap;
    }

    const content = fs.readFileSync(filePath, 'utf8');
    const lines = content.split('\n');

    for (const line of lines) {
      const trimmed = line.trim();
      if (trimmed && !trimmed.startsWith('#')) {
        const [key, ...valueParts] = trimmed.split('=');
        if (key && valueParts.length > 0) {
          const value = valueParts.join('=').replace(/^["']|["']$/g, ''); // Remove quotes
          envMap.set(key.trim(), value);
        }
      }
    }

    return envMap;
  }

  private writeEnvFile(filePath: string, envMap: Map<string, string>): void {
    // Read existing file to preserve comments and structure
    let existingContent = '';
    if (fs.existsSync(filePath)) {
      existingContent = fs.readFileSync(filePath, 'utf8');
    }

    const lines = existingContent ? existingContent.split('\n') : [];
    const processedKeys = new Set<string>();
    
    // Update existing lines
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      if (line && !line.startsWith('#')) {
        const [key] = line.split('=');
        if (key && envMap.has(key.trim())) {
          const cleanKey = key.trim();
          lines[i] = `${cleanKey}=${envMap.get(cleanKey)}`;
          processedKeys.add(cleanKey);
        }
      }
    }

    // Add new keys that weren't in the existing file
    for (const [key, value] of envMap) {
      if (!processedKeys.has(key)) {
        lines.push(`${key}=${value}`);
      }
    }

    // Ensure file ends with newline
    const content = lines.join('\n');
    fs.writeFileSync(filePath, content.endsWith('\n') ? content : content + '\n');
  }

  private isPlaceholderValue(value: string): boolean {
    const placeholders = [
      'replace_me',
      'changeme',
      'your_secret_here',
      'your_key_here',
      'your_token_here',
      'placeholder',
      'change_this'
    ];

    const normalizedValue = value.toLowerCase().trim();
    return placeholders.includes(normalizedValue) || 
           /^your_.+_here$/i.test(normalizedValue) ||
           normalizedValue.length < 8; // Too short to be a real secret
  }

  private maskSensitiveValue(key: string, value: string): string {
    const sensitivePatterns = ['SECRET', 'KEY', 'TOKEN', 'PASSWORD'];
    const isSensitive = sensitivePatterns.some(pattern => 
      key.toUpperCase().includes(pattern)
    );

    if (isSensitive && value.length > 8) {
      return `${value.substring(0, 4)}${'*'.repeat(Math.min(value.length - 8, 20))}${value.substring(value.length - 4)}`;
    }

    return value.length > 50 ? `${value.substring(0, 47)}...` : value;
  }

  private printSummary(): void {
    console.log(chalk.blue.bold('\nüìä Bootstrap Summary'));
    console.log(chalk.gray('='.repeat(50)));

    if (this.actions.length === 0) {
      console.log(chalk.green('‚úÖ Environment already properly configured'));
      console.log(chalk.blue('‚ÑπÔ∏è  No changes were needed'));
    } else {
      console.log(chalk.green(`‚úÖ Bootstrap completed successfully`));
      console.log(chalk.blue(`üìù Actions performed (${this.actions.length}):`));
      this.actions.forEach((action, index) => {
        console.log(chalk.gray(`   ${index + 1}. ${action}`));
      });
    }

    // File locations
    console.log(chalk.cyan.bold('\nüìÅ Configuration Files'));
    console.log(chalk.gray('‚îÄ'.repeat(30)));
    console.log(chalk.blue('   Backend:'), chalk.gray('backend/.env'));
    console.log(chalk.blue('   Frontend:'), chalk.gray('frontend/.env.local'));

    // Next steps
    console.log(chalk.cyan.bold('\nüöÄ Next Steps'));
    console.log(chalk.gray('‚îÄ'.repeat(20)));
    console.log(chalk.blue('1. Validate configuration:'), chalk.white('npm run env:doctor'));
    console.log(chalk.blue('2. Validate strictly:'), chalk.white('npm run env:doctor:strict'));
    console.log(chalk.blue('3. Start development:'), chalk.white('npm run dev:all'));

    // Security note
    if (this.actions.some(action => action.includes('Generated secure'))) {
      console.log(chalk.yellow.bold('\n‚ö†Ô∏è  Security Notice'));
      console.log(chalk.yellow('Generated secrets are for DEVELOPMENT ONLY'));
      console.log(chalk.yellow('Use proper secret management in production'));
    }

    console.log(); // Final spacing
  }
}

// CLI execution
async function main(): Promise<void> {
  const bootstrap = new EnvironmentBootstrap();
  await bootstrap.bootstrap();
}

// Run the bootstrap
if (import.meta.url === `file://${__filename}`) {
  main().catch(error => {
    console.error(chalk.red.bold('\nüí• Bootstrap crashed:'));
    console.error(chalk.red(error.message));
    if (error.stack) {
      console.error(chalk.gray(error.stack));
    }
    process.exit(2);
  });
}

export { EnvironmentBootstrap };
