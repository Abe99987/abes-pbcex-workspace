#!/usr/bin/env ts-node

import * as fs from 'fs';
import * as path from 'path';
import * as url from 'url';
import * as crypto from 'crypto';
import * as dotenv from 'dotenv';
import chalk from 'chalk';

// ES module equivalent of __dirname
const __filename = url.fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const ROOT_DIR = path.dirname(__dirname);

/**
 * PBCEx Secrets Injector üîê
 * 
 * Generates and injects secure secrets into backend/.env:
 * - JWT_SECRET: 48 random bytes (base64url encoded)
 * - SESSION_SECRET: 48 random bytes (base64url encoded)  
 * - ENCRYPTION_KEY: 32 random bytes (64 hex characters)
 * 
 * Idempotent - only generates if missing or placeholder values
 * Preserves existing real values - won't overwrite production secrets
 * 
 * Usage: npm run secrets:set
 */

interface SecretConfig {
  key: string;
  generator: () => string;
  description: string;
  maskPattern: string;
}

class SecretsInjector {
  private backendEnvPath: string;
  private envContent: Map<string, string> = new Map();
  private generatedSecrets: Array<{ key: string; value: string; masked: string }> = [];

  constructor() {
    this.backendEnvPath = path.join(ROOT_DIR, 'backend', '.env');
    console.log(chalk.blue.bold('\nüîê PBCEx Secrets Injector\n'));
    console.log(chalk.gray('Generating secure secrets for development...\n'));
  }

  async inject(): Promise<void> {
    try {
      // Step 1: Ensure backend/.env exists
      await this.ensureBackendEnvExists();

      // Step 2: Load current environment
      this.loadEnvironment();

      // Step 3: Generate missing secrets
      await this.generateMissingSecrets();

      // Step 4: Write back to file
      this.writeEnvironment();

      // Step 5: Print summary
      this.printSummary();

    } catch (error) {
      console.error(chalk.red.bold('\nüí• Secrets injection failed:'));
      console.error(chalk.red(error.message));
      process.exit(1);
    }
  }

  private async ensureBackendEnvExists(): Promise<void> {
    console.log(chalk.cyan.bold('üìÑ Environment File Check'));
    console.log(chalk.gray('‚îÄ'.repeat(30)));

    if (!fs.existsSync(this.backendEnvPath)) {
      const templatePath = path.join(ROOT_DIR, 'backend', 'env-template');
      
      if (fs.existsSync(templatePath)) {
        fs.copyFileSync(templatePath, this.backendEnvPath);
        console.log(chalk.green('   ‚úÖ Created backend/.env from template'));
      } else {
        // Create minimal .env file
        const minimalEnv = `# PBCEx Backend Environment
# Generated by Secrets Injector

NODE_ENV=development
PORT=4001
DATABASE_URL=postgresql://postgres:postgres@localhost:5432/pbcex
REDIS_URL=redis://localhost:6379

# Authentication & Security
JWT_SECRET=
SESSION_SECRET=
ENCRYPTION_KEY=

# Feature Flags
PHASE=1
ENABLE_ONCHAIN=false
ENABLE_VAULT_REDEMPTION=false
FULFILLMENT_STRATEGY=JM
`;
        fs.writeFileSync(this.backendEnvPath, minimalEnv);
        console.log(chalk.green('   ‚úÖ Created minimal backend/.env'));
      }
    } else {
      console.log(chalk.blue('   ‚ÑπÔ∏è  backend/.env already exists'));
    }
  }

  private loadEnvironment(): void {
    console.log(chalk.cyan.bold('\nüîç Loading Current Environment'));
    console.log(chalk.gray('‚îÄ'.repeat(35)));

    const content = fs.readFileSync(this.backendEnvPath, 'utf8');
    const lines = content.split('\n');

    for (const line of lines) {
      const trimmed = line.trim();
      if (trimmed && !trimmed.startsWith('#')) {
        const [key, ...valueParts] = trimmed.split('=');
        if (key && valueParts.length > 0) {
          const value = valueParts.join('=').replace(/^["']|["']$/g, ''); // Remove quotes
          this.envContent.set(key.trim(), value);
        }
      }
    }

    console.log(chalk.green(`   ‚úÖ Loaded ${this.envContent.size} environment variables`));
  }

  private async generateMissingSecrets(): Promise<void> {
    console.log(chalk.cyan.bold('\nüîê Secret Generation'));
    console.log(chalk.gray('‚îÄ'.repeat(25)));

    const secretConfigs: SecretConfig[] = [
      {
        key: 'JWT_SECRET',
        generator: () => crypto.randomBytes(48).toString('base64url'),
        description: 'JSON Web Token signing secret',
        maskPattern: '****'
      },
      {
        key: 'SESSION_SECRET',
        generator: () => crypto.randomBytes(48).toString('base64url'),
        description: 'Session cookie signing secret',
        maskPattern: '****'
      },
      {
        key: 'ENCRYPTION_KEY',
        generator: () => {
          // Ensure exactly 32 bytes = 64 hex characters
          const bytes = crypto.randomBytes(32);
          return bytes.toString('hex');
        },
        description: 'Data encryption key (64 hex chars)',
        maskPattern: '****'
      }
    ];

    for (const config of secretConfigs) {
      const currentValue = this.envContent.get(config.key);
      const needsGeneration = !currentValue || 
                             currentValue.trim() === '' ||
                             this.isPlaceholderValue(currentValue);

      if (needsGeneration) {
        const generatedValue = config.generator();
        this.envContent.set(config.key, generatedValue);
        
        const maskedValue = this.maskSecret(generatedValue, config.maskPattern);
        this.generatedSecrets.push({
          key: config.key,
          value: generatedValue,
          masked: maskedValue
        });

        console.log(chalk.green(`   ‚úÖ Generated ${config.key}`), chalk.gray(`(${config.description})`));
      } else {
        const maskedValue = this.maskSecret(currentValue!, config.maskPattern);
        console.log(chalk.blue(`   ‚ÑπÔ∏è  ${config.key} already configured`), chalk.gray(`= ${maskedValue}`));
      }
    }
  }

  private isPlaceholderValue(value: string): boolean {
    const placeholders = [
      'replace_me',
      'changeme',
      'your_secret_here',
      'your_key_here',
      'your_token_here',
      'placeholder',
      'change_this',
      'replace_me_with_secure_random_string',
      'replace_me_with_32_byte_key'
    ];

    const normalizedValue = value.toLowerCase().trim();
    
    // Check for exact placeholder matches
    if (placeholders.includes(normalizedValue)) {
      return true;
    }
    
    // Check for pattern placeholders
    if (/^your_.+_here$/i.test(normalizedValue)) {
      return true;
    }
    
    // Check for too short values (but allow ENCRYPTION_KEY to be 64 chars)
    if (normalizedValue.length < 8) {
      return true;
    }
    
    // Special check for ENCRYPTION_KEY - must be exactly 64 hex characters
    if (normalizedValue.length === 64 && /^[0-9a-fA-F]{64}$/.test(normalizedValue)) {
      return false; // Valid hex string of correct length
    }
    
    return false;
  }

  private maskSecret(value: string, pattern: string): string {
    if (value.length <= 8) {
      return value; // Don't mask very short values
    }
    return `${value.substring(0, 4)}${pattern}${value.substring(value.length - 4)}`;
  }

  private writeEnvironment(): void {
    console.log(chalk.cyan.bold('\nüíæ Writing Environment'));
    console.log(chalk.gray('‚îÄ'.repeat(25)));

    // Read existing file to preserve comments and structure
    let existingContent = '';
    if (fs.existsSync(this.backendEnvPath)) {
      existingContent = fs.readFileSync(this.backendEnvPath, 'utf8');
    }

    const lines = existingContent ? existingContent.split('\n') : [];
    const processedKeys = new Set<string>();
    
    // Update existing lines
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      if (line && !line.startsWith('#')) {
        const [key] = line.split('=');
        if (key && this.envContent.has(key.trim())) {
          const cleanKey = key.trim();
          lines[i] = `${cleanKey}=${this.envContent.get(cleanKey)}`;
          processedKeys.add(cleanKey);
        }
      }
    }

    // Add new keys that weren't in the existing file
    for (const [key, value] of this.envContent) {
      if (!processedKeys.has(key)) {
        lines.push(`${key}=${value}`);
      }
    }

    // Ensure file ends with newline
    const content = lines.join('\n');
    fs.writeFileSync(this.backendEnvPath, content.endsWith('\n') ? content : content + '\n');

    console.log(chalk.green('   ‚úÖ Environment file updated'));
  }

  private printSummary(): void {
    console.log(chalk.blue.bold('\nüìä Secrets Summary'));
    console.log(chalk.gray('='.repeat(35)));

    if (this.generatedSecrets.length === 0) {
      console.log(chalk.blue('‚ÑπÔ∏è  All secrets already properly configured'));
      console.log(chalk.gray('No new secrets were generated'));
    } else {
      console.log(chalk.green(`‚úÖ Generated ${this.generatedSecrets.length} new secret(s)`));
      
      console.log(chalk.cyan.bold('\nüîê Generated Secrets (Masked)'));
      console.log(chalk.gray('‚îÄ'.repeat(35)));
      
      for (const secret of this.generatedSecrets) {
        console.log(chalk.blue(`   ${secret.key}:`), chalk.white(secret.masked));
      }
    }

    // Security notice
    console.log(chalk.yellow.bold('\n‚ö†Ô∏è  Security Notice'));
    console.log(chalk.yellow('‚Ä¢ Generated secrets are for DEVELOPMENT ONLY'));
    console.log(chalk.yellow('‚Ä¢ Use proper secret management in production'));
    console.log(chalk.yellow('‚Ä¢ Never commit real secrets to version control'));

    // File location
    console.log(chalk.cyan.bold('\nüìÅ File Location'));
    console.log(chalk.gray('‚îÄ'.repeat(20)));
    console.log(chalk.blue('   Backend Environment:'), chalk.gray(path.relative(ROOT_DIR, this.backendEnvPath)));

    console.log(); // Final spacing
  }
}

// CLI execution
async function main(): Promise<void> {
  const injector = new SecretsInjector();
  await injector.inject();
}

// Run the secrets injector
if (import.meta.url === `file://${__filename}`) {
  main().catch(error => {
    console.error(chalk.red.bold('\nüí• Secrets injector crashed:'));
    console.error(chalk.red(error.message));
    if (error.stack) {
      console.error(chalk.gray(error.stack));
    }
    process.exit(2);
  });
}

export { SecretsInjector };
